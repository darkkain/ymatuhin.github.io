Партизанский рефакторинг или ребота с говнокодом в JavaScript.

"Или как улучшить проект, чтобы заказчик этого не понял".
"Работа c говнокодом".

Сегодня мы поговорим о говнокоде. В следующих статьях мы будем обсуждать архитектуру, но все это может разбиться о рабочие будни. Дома у вас может быть "идеальный проект", с хорошей архитектурой, но на работе — jQuery. А мы, как профессионалы, должны быть к этому готовы.

Представьте, что вы попали на проект, написанный в лучших традициях говнокода.
В нем не понятно как и что работает. Вам естественно нужно что-то в нем сделать.

У нас может быть 2 типа задач:
– фикс багов;
– новая функциональность;

Если это фикс багов, то у нас есть сильно связаный модуль, в котором тесно сплетены три слоя абстракции (нет разделения между Model View Controller).

```
      [*] [*] [*]
        \  |  /
[*] – [ модуль ] – [*]
        /  |  \
      [*] [*] [*]
```

Простейший пример такого кода — работа с jQuery. Где делается AJAX запрос, в колбеке мы что-то делаем с данными, а потом все выводим в HTML — типичная ситуация.

Чтобы этот проект даже в таком состоянии продолжал свое существование, нужно сделать несколько вещей:

1. Первое что мы должны делать — чистые функции.
В математике функция – отражение агрументов на результат.
При x = 3, функция вида y = x^2 всегда будет равна 9.
В программировании чистая функция не должна менять ничего вне себя и напрямую изменять аргументы.

fn( [ бизнеслогика ] ) -> ( ... )

Если вы можем, то функция должна возвращать новый объект. Но если этот объект сильно завязан с другими частями, то так просто мы это сделать не можем. В этом случае наша функция должна генерировать патч, который при наложении (extend/merge) на основной объект получит желаемый результат.

Это нужно для того, чтобы мы могли представить работу с объектом бизнес логики как цепочку изменений, которую мы можем легко отследить (console.log).
Визуально получается следующее:

```
[ &––1––2––3 ] –> #
  |  |  |  |
  | →|  |  |
     | →|  |
        | →|
           |
           ↓
```

& – наш начальный объект, # – новое (измененное) состояние.

А если нам надо изменять html?
Мы можем перерисовывать html на кадом этапе свертки (в местах где →| ).
Проблема в том, что маленьких изменений может быть 1000000000. И перерисовывать html на каждый чих — так себе вариант.

Представим, что у нас есть html сущность, в которую лезут непонятно откуда и непонятно кто, все кто может.

```
   ↓ ↓ ↓
→ [ html ] ←
```

Сначала нам нужно найти места, откуда туда лезут. В этом нам поможет установка точки останова на дерево в дебагере. Ставим точку останова, и получаем список мест, которые меняют этот html. Конечно вы вероятно найдете не все места, но это уже что-то и есть с чего начать.

Окей, нашли. Что дальше?
Хорошо бы заменить все места, в которых работают с html на какую-нибудь функцию. В которую нам передается состояние объекта и на выходе делается UI/html или меняется исходный html прямо в этой функции.

Окей, заменили. Но проблему тормозов не решает. Что делать?
Логично проверять какие данные изменились и проверять нужно ли нам что-то менять в html. Поздравляю, мы только что изобрели React.

В React все есть компонент. У компонента есть props (данные которые передали снаружи), state (внутреннее состояние объекта) и функция Render (отображает props и state). Props у компонента доступны только для чтения. Это и есть основная идея React-a. Поскольку React это не фреймворк, а библиотека, то мы можем завязать только один компонент на него, внезависимости от основного фреймворка в приложении.
